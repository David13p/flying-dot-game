<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <title>Flying Dot</title>
    <link rel="icon" href="icon.png">
    <link rel="stylesheet" href="style.css"> 
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="scoreDisplay">0</div>
        <div id="speedDisplay">Speed: 0.0</div>
        <div id="gameUI">
            <div id="message">Flappy Dot</div>
            <div id="finalScore" style="display: none;"></div>
            <div id="highScoreDisplay" style="display: none;"></div>
            <button id="startButton" class="game-button">Start Game</button>
        </div>
    </div>

    <div id="mobileMessage">
        <p>This game is currently only playable using a mouse and keyboard.</p>
        <p>Please access it from a desktop or laptop computer.</p>
    </div>

    <div class="links-container">
        <a class="link-button github-link" href="https://github.com/David13p/flying-dot-game" target="_blank">
            <img src="https://github.githubassets.com/assets/GitHub-Mark-ea2971cee799.png" alt="GitHub Logo">GitHub Repo
        </a>
        <a class="link-button donate-button" href="https://your-donation-link.com" target="_blank">
            ðŸ’– Maybe consider donating
        </a>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const gameUI = document.getElementById('gameUI');
        const messageDisplay = document.getElementById('message');
        const finalScoreDisplay = document.getElementById('finalScore');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const startButton = document.getElementById('startButton');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const speedDisplay = document.getElementById('speedDisplay');
        const mobileMessage = document.getElementById('mobileMessage');
        const gameContainer = document.getElementById('gameContainer');

        const DOT_RADIUS = 15;
        const OBSTACLE_WIDTH = 60;
        const OBSTACLE_SPACING = 200;

        const BASE_MIN_GAP_HEIGHT = 100;
        const BASE_MAX_GAP_HEIGHT = 180;
        const MAX_GAP_MIN_HEIGHT = 150;
        const MAX_GAP_MAX_HEIGHT = 250;

        const INITIAL_GAME_SPEED = 7.5;
        const MAX_GAME_SPEED = 9;
        const SPEED_INCREASE_RATE = 0.0002;

        let dot = { x: canvas.width / 2, y: canvas.height / 2, radius: DOT_RADIUS };
        let obstacles = [];
        let score = 0;
        let highScore = localStorage.getItem('flappyDotHighScore') || 0;
        let gameSpeed = INITIAL_GAME_SPEED;
        let gameOver = true;
        let gameStarted = false;
        let animationFrameId;
        let dotTrail = [];
        const MAX_TRAIL_LENGTH = 100;
        let currentScrollOffset = 0;

        let effectiveMinGapHeight = BASE_MIN_GAP_HEIGHT;
        let effectiveMaxGapHeight = BASE_MAX_GAP_HEIGHT;

        const pointSound = new Audio('point.mp3');

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            if (!gameStarted || gameOver) {
                dot.x = canvas.width / 2;
                dot.y = canvas.height / 2;
            }
            if (!gameOver) draw();
        }

        function checkDeviceAndDisplay() {
            const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            if (isMobile) {
                mobileMessage.style.display = 'flex';
                gameContainer.style.display = 'none';
            } else {
                mobileMessage.style.display = 'none';
                gameContainer.style.display = 'flex';
                resizeCanvas();
            }
        }

        window.onload = function() {
            checkDeviceAndDisplay();
            showUI("Flappy Dot", "Start Game", false, true);
            speedDisplay.textContent = `Speed: ${INITIAL_GAME_SPEED.toFixed(1)}`;
        };

        window.addEventListener('resize', checkDeviceAndDisplay);

        canvas.addEventListener('mousemove', (e) => {
            if (!gameOver && gameStarted) {
                const rect = canvas.getBoundingClientRect();
                dot.x = Math.max(dot.radius, Math.min(canvas.width - dot.radius, e.clientX - rect.left));
                dot.y = Math.max(dot.radius, Math.min(canvas.height - dot.radius, e.clientY - rect.top));
            }
        });

        function drawDot() {
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#e74c3c';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            ctx.fill();
            ctx.closePath();
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        function drawDotTrail() {
            if (dotTrail.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(dotTrail[0].x, dotTrail[0].y);
            for (let i = 1; i < dotTrail.length; i++) ctx.lineTo(dotTrail[i].x, dotTrail[i].y);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
            ctx.closePath();
        }

        function drawObstacle(x, y, width, height) {
            ctx.fillStyle = '#27ae60';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            ctx.fillRect(x, y, width, height);
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, width, height);
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        function generateObstacle() {
            const gapHeight = effectiveMinGapHeight + Math.random() * (effectiveMaxGapHeight - effectiveMinGapHeight);
            const gapY = Math.random() * (canvas.height - gapHeight);
            obstacles.push({
                x: canvas.width + currentScrollOffset,
                y1: 0,
                height1: gapY,
                x2: canvas.width + currentScrollOffset,
                y2: gapY + gapHeight,
                height2: canvas.height - (gapY + gapHeight),
                width: OBSTACLE_WIDTH,
                passed: false
            });
        }

        function update() {
            if (gameOver) return;
            currentScrollOffset += gameSpeed;
            dotTrail.push({ x: dot.x + currentScrollOffset, y: dot.y });
            while (dotTrail.length > MAX_TRAIL_LENGTH) dotTrail.shift();
            dotTrail = dotTrail.filter(point => point.x > currentScrollOffset - dot.radius);

            const dotWorldX = dot.x + currentScrollOffset;

            for (let i = 0; i < obstacles.length; i++) {
                if (dotWorldX + dot.radius > obstacles[i].x &&
                    dotWorldX - dot.radius < obstacles[i].x + obstacles[i].width &&
                    dot.y - dot.radius < obstacles[i].height1) return endGame();

                if (dotWorldX + dot.radius > obstacles[i].x2 &&
                    dotWorldX - dot.radius < obstacles[i].x2 + obstacles[i].width &&
                    dot.y + dot.radius > obstacles[i].y2) return endGame();

                if (!obstacles[i].passed && obstacles[i].x + obstacles[i].width < dotWorldX) {
                    score++;
                    obstacles[i].passed = true;
                    scoreDisplay.textContent = score;
                    if (score % 10 === 0) {
                        pointSound.currentTime = 0;
                        pointSound.play();
                    }
                }
            }

            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > currentScrollOffset);

            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - OBSTACLE_SPACING + currentScrollOffset) generateObstacle();

            if (dot.y - dot.radius < 0 || dot.y + dot.radius > canvas.height) return endGame();

            gameSpeed = Math.min(MAX_GAME_SPEED, gameSpeed + SPEED_INCREASE_RATE);
            speedDisplay.textContent = `Speed: ${gameSpeed.toFixed(1)}`;

            let speedProgress = (gameSpeed - INITIAL_GAME_SPEED) / (MAX_GAME_SPEED - INITIAL_GAME_SPEED);
            speedProgress = Math.max(0, Math.min(1, speedProgress));

            effectiveMinGapHeight = BASE_MIN_GAP_HEIGHT + (MAX_GAP_MIN_HEIGHT - BASE_MIN_GAP_HEIGHT) * speedProgress;
            effectiveMaxGapHeight = BASE_MAX_GAP_HEIGHT + (MAX_GAP_MAX_HEIGHT - BASE_MAX_GAP_HEIGHT) * speedProgress;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(-currentScrollOffset, 0);

            drawDotTrail();
            obstacles.forEach(obstacle => {
                drawObstacle(obstacle.x, obstacle.y1, obstacle.width, obstacle.height1);
                drawObstacle(obstacle.x2, obstacle.y2, obstacle.width, obstacle.height2);
            });

            ctx.restore();
            drawDot();
        }

        function gameLoop() {
            update();
            draw();
            if (!gameOver) animationFrameId = requestAnimationFrame(gameLoop);
        }

        function showUI(message, buttonText, showFinalScore = false, showHighScore = false) {
            messageDisplay.textContent = message;
            startButton.textContent = buttonText;
            finalScoreDisplay.style.display = showFinalScore ? 'block' : 'none';
            if (showFinalScore) finalScoreDisplay.textContent = `Score: ${score}`;
            highScoreDisplay.style.display = showHighScore ? 'block' : 'none';
            if (showHighScore) highScoreDisplay.textContent = `High Score: ${highScore}`;
            gameUI.classList.remove('hidden');
        }

        function hideUI() {
            gameUI.classList.add('hidden');
        }

        function startGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            initGame();
            hideUI();
            gameLoop();
            gameStarted = true;
        }

        function initGame() {
            dot.x = canvas.width / 2;
            dot.y = canvas.height / 2;
            obstacles = [];
            score = 0;
            gameSpeed = INITIAL_GAME_SPEED;
            gameOver = false;
            dotTrail = [];
            currentScrollOffset = 0;
            scoreDisplay.textContent = score;
            speedDisplay.textContent = `Speed: ${gameSpeed.toFixed(1)}`;
            effectiveMinGapHeight = BASE_MIN_GAP_HEIGHT;
            effectiveMaxGapHeight = BASE_MAX_GAP_HEIGHT;
            generateObstacle();
        }

        function endGame() {
            gameOver = true;
            gameStarted = false;
            cancelAnimationFrame(animationFrameId);
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flappyDotHighScore', highScore);
            }
            showUI("Game Over!", "Play Again", true, true);
        }

        startButton.addEventListener('click', startGame);
    </script>
</body>
</html>


